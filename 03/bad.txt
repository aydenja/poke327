static void dijkstra_square(map_t *m, pair_t player){
  static square_t square[MAP_Y][MAP_X], *p;
  static uint32_t initialized = 0;
  heap_t h;
  uint32_t x, y;

  if (!initialized) {
    for (y = 0; y < MAP_Y; y++) {
      for (x = 0; x < MAP_X; x++) {
        square[y][x].pos[dim_y] = y;
        square[y][x].pos[dim_x] = x;
        square[y][x].t = m->map[y][x];
      }
    }
    initialized = 1;
  }

  //set all costs to max
  for (y = 0; y < MAP_Y; y++) {
    for (x = 0; x < MAP_X; x++) {
      square[y][x].cost = INT_MAX;
    }
  }

  square[player[dim_y]][player[dim_x]].cost = 0;

  heap_init(&h, path_cmp, NULL);

  //insert every square into heap
  for (y = 1; y < MAP_Y - 1; y++) {
    for (x = 1; x < MAP_X - 1; x++) {
      square[y][x].hn = heap_insert(&h, &square[y][x]);
    }
  }


  //while heap is not empty remove smallest thing
  while ((p = heap_remove_min(&h))) {
    p->hn = NULL;


    //start from line 186
    //may need to pass a cost function as a param

    //new!!
    if ((square[p->pos[dim_y] - 1][p->pos[dim_x]    ].hn) &&
        (square[p->pos[dim_y] - 1][p->pos[dim_x]    ].cost >
         ((p->cost + get_hiker_cost(p->t))))) {
            square[p->pos[dim_y] - 1][p->pos[dim_x]    ].cost =
              p->cost + get_hiker_cost(p->t);
            heap_decrease_key_no_replace(&h, square[p->pos[dim_y] - 1]
                                                 [p->pos[dim_x]    ].hn);
    }

    if ((square[p->pos[dim_y] + 1][p->pos[dim_x]    ].hn) &&
        (square[p->pos[dim_y] + 1][p->pos[dim_x]    ].cost >
         ((p->cost + get_hiker_cost(p->t))))) {
            square[p->pos[dim_y] + 1][p->pos[dim_x]    ].cost =
              p->cost + get_hiker_cost(p->t);
            heap_decrease_key_no_replace(&h, square[p->pos[dim_y] + 1]
                                                 [p->pos[dim_x]    ].hn);
    }

    if ((square[p->pos[dim_y]    ][p->pos[dim_x] -1 ].hn) &&
        (square[p->pos[dim_y]    ][p->pos[dim_x] -1 ].cost >
         ((p->cost + get_hiker_cost(p->t))))) {
            square[p->pos[dim_y]    ][p->pos[dim_x] -1 ].cost =
              p->cost + get_hiker_cost(p->t);
            heap_decrease_key_no_replace(&h, square[p->pos[dim_y]    ]
                                                 [p->pos[dim_x]  -1].hn);
    }

    if ((square[p->pos[dim_y]    ][p->pos[dim_x] +1 ].hn) &&
        (square[p->pos[dim_y]    ][p->pos[dim_x] +1 ].cost >
         ((p->cost + get_hiker_cost(p->t))))) {
            square[p->pos[dim_y]    ][p->pos[dim_x] +1 ].cost =
              p->cost + get_hiker_cost(p->t);
            heap_decrease_key_no_replace(&h, square[p->pos[dim_y]    ]
                                                 [p->pos[dim_x]  +1].hn);
    }
    
  }



  for (y = 1; y < MAP_Y-1; y++) {
    for (x = 1; x < MAP_X-1; x++) {
      printf("%d ", square[y][x].cost);
    }
    printf("\n");
  }

  heap_delete(&h);
  return;


}